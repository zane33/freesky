:{$PORT}

log {
	format json
	level DEBUG
}

# Optimized compression settings - exclude streaming endpoints
@compress {
    not path /api/stream/* /api/content/* /api/key/* /stream/* /content/* /key/* /_event/* /logo/* /watch/*
}
encode @compress {
    gzip 6          # Balanced compression level
    zstd            # Enable zstd for better compression
}
root * /srv

# Cache static assets aggressively
@static_assets {
    path *.js *.css *.woff *.woff2 *.ttf *.png *.jpg *.jpeg *.gif *.ico *.svg
}
header @static_assets {
    Cache-Control "public, max-age=31536000, immutable"
}

# Streaming endpoints need permissive headers for external players
@streaming {
    path /api/stream/* /api/content/* /api/key/* /stream/* /content/* /key/* /playlist.m3u8
}

# Restrictive headers for non-streaming content
@non_streaming {
    not path /api/stream/* /api/content/* /api/key/* /stream/* /content/* /key/* /playlist.m3u8
}

# Security headers for non-streaming content only
header @non_streaming {
	X-Content-Type-Options nosniff
	X-Frame-Options DENY
	X-XSS-Protection "1; mode=block"
	Referrer-Policy "strict-origin-when-cross-origin"
	Permissions-Policy "geolocation=(), microphone=(), camera=()"
}

# Permissive headers for streaming content (for VLC and external players)
header @streaming {
	X-Content-Type-Options nosniff
	Access-Control-Allow-Origin "*"
	Access-Control-Allow-Methods "GET, POST, OPTIONS"
	Access-Control-Allow-Headers "*"
	Access-Control-Expose-Headers "*"
	Cache-Control "no-cache, no-store, must-revalidate"
	Pragma "no-cache"
	Expires "0"
}

# Handle playlist.m3u8 endpoint first (highest priority)
handle /playlist.m3u8 {
	reverse_proxy localhost:{$BACKEND_PORT}
}

# Handle EPG XML endpoint 
handle /epg.xml {
	reverse_proxy localhost:{$BACKEND_PORT}
	header {
		Content-Type "application/xml"
		Access-Control-Allow-Origin "*"
		Access-Control-Allow-Methods "GET, OPTIONS"
		Access-Control-Allow-Headers "*"
	}
}

# Handle logo requests first (highest priority)
handle /logo/* {
	reverse_proxy localhost:{$BACKEND_PORT}
}

# Handle WebSocket events - match path only, let backend handle WebSocket upgrade
@websocket path /_event*
handle @websocket {
	reverse_proxy localhost:{$BACKEND_PORT}
}

# Handle API endpoints - most specific first
@api_stream path /api/stream/*
handle @api_stream {
	reverse_proxy localhost:{$BACKEND_PORT} {
		flush_interval -1
		header_up X-Real-IP {remote_host}
		header_down -Server
		# Optimize for M3U8 delivery
		transport http {
			read_buffer 8192      # Smaller buffer for playlist delivery
			write_buffer 8192
			max_response_header 8KB
			dial_timeout 2s       # Fast timeout for playlists
			response_header_timeout 5s
		}
	}
}

@api_logo path /api/logo/*
handle @api_logo {
	reverse_proxy localhost:{$BACKEND_PORT} {
		flush_interval -1
		header_up X-Real-IP {remote_host}
		header_down -Server
	}
}


@api_key path /api/key/*
handle @api_key {
	reverse_proxy localhost:{$BACKEND_PORT} {
		flush_interval -1
		header_up X-Real-IP {remote_host}
	}
}

@api_content path /api/content/*
handle @api_content {
	reverse_proxy localhost:{$BACKEND_PORT} {
		flush_interval -1
		header_up X-Real-IP {remote_host}
		header_down -Server
		# Optimize for streaming
		transport http {
			read_buffer 16384     # 16KB read buffer
			write_buffer 16384    # 16KB write buffer
			max_response_header 16KB
			dial_timeout 3s
			response_header_timeout 10s
		}
	}
}

# Handle other API endpoints
@api path /api/*
handle @api {
	reverse_proxy localhost:{$BACKEND_PORT}
}

# Handle specific backend endpoints
handle /health {
	reverse_proxy localhost:{$BACKEND_PORT}
}

handle /channels {
	reverse_proxy localhost:{$BACKEND_PORT}
}

handle /ping {
	reverse_proxy localhost:{$BACKEND_PORT}
}

handle /schedule {
	reverse_proxy localhost:{$BACKEND_PORT}
}

# Handle all other requests
handle {
	# Try static files first
	try_files {path} /index.html
	file_server
}